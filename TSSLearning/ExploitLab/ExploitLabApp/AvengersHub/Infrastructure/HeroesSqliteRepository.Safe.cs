using ExploitLabApp.Heroes.Application;
using ExploitLabApp.Heroes.Domain;
using Microsoft.Data.Sqlite;

namespace ExploitLabApp.Heroes.Infrastructure;

public class HeroesSqliteSafeRepository : IHeroesRepository
{
  private readonly string _connectionString;

  public HeroesSqliteSafeRepository(string connectionString)
  {
    if (string.IsNullOrWhiteSpace(connectionString))
      throw new ArgumentNullException(nameof(connectionString));

    _connectionString = connectionString;
  }

  protected List<Hero> GetByCommand(Action<SqliteCommand> SetCommand)
  {
    List<Hero> readHeroes = Enumerable.Empty<Hero>().ToList();

    using (var conn = new SqliteConnection(_connectionString))
    {
      conn.Open();
      using var cmd = conn.CreateCommand();
      SetCommand(cmd);
      using var reader = cmd.ExecuteReader();
      while (reader.Read())
      {
        string name = reader.GetString(0);
        string firstName = reader.GetString(1);
        string email = reader.GetString(2);
        readHeroes.Add(new Hero { HeroName = name, Power = firstName, Email = email });
      }
    }

    return readHeroes;
  }

  public Task<List<Hero>> GetByPatternAsync(string? searchPattern = null)
  {
    return Task.FromResult(GetByCommand(cmd => SetReadHeroesCommand(cmd, searchPattern)));
  }

  public Task AddAsync(Hero hero)
  {
    string heroName = hero.HeroName;
    string power = hero.Power;
    string email = hero.Email;

    if (string.IsNullOrWhiteSpace(heroName))
      throw new ArgumentException("Hero name is required", nameof(hero));
    if (string.IsNullOrWhiteSpace(power))
      throw new ArgumentException("Power is required", nameof(hero));
    if (string.IsNullOrWhiteSpace(email))
      throw new ArgumentException("Email is required", nameof(hero));

    using (var conn = new SqliteConnection(_connectionString))
    {
      conn.Open();
      using var cmd = conn.CreateCommand();

      // To avoid:
      // x', 'x', (SELECT IFNULL(HeroName, '[no HeroName]') || ' | ' || IFNULL(RealName, '[no RealName]') || ' | ' || IFNULL(RealFirstName, '[no RealFirstName]') AS HeroName FROM SecretIdentities)); --

      cmd.CommandText = "INSERT INTO Heroes (HeroName, Power, Email) VALUES (@heroName, @power, @eMail);";
      cmd.Parameters.Add(new SqliteParameter("@heroName", heroName));
      cmd.Parameters.Add(new SqliteParameter("@power", power));
      cmd.Parameters.Add(new SqliteParameter("@eMail", email));

      // Or (other syntax)      
      //cmd.Parameters.AddWithValue("@heroName", heroName);
      //cmd.Parameters.AddWithValue("@power", power);
      //cmd.Parameters.AddWithValue("@eMail", email);

      int rows = cmd.ExecuteNonQuery();
      if (rows != 1)
        throw new InvalidOperationException("Error during hero creation");
    }

    return Task.CompletedTask;
  }

  public static void SetReadHeroesCommand(SqliteCommand readcommand, string? searchPattern = null)
  {
    string sqlBaseQuery = $"SELECT HeroName, Power, Email FROM Heroes";
    if (string.IsNullOrWhiteSpace(searchPattern))
    {
      readcommand.CommandText = sqlBaseQuery;
      return;
    }

    // To avoid:

    // xxx' UNION SELECT sqlite_version(), 'x', 'x';
    // xxx' UNION SELECT IFNULL(type, '[no type]') || ' | ' || IFNULL(name, '[no name]') || ' | ' || IFNULL(tbl_name, '[no tbl_name]') || ' | ' || IFNULL(sql, '[no sql]') AS HeroName, 'x', 'x' FROM sqlite_master; --
    // xxx' UNION SELECT IFNULL(HeroName, '[no HeroName]') || ' | ' || IFNULL(RealName, '[no RealName]') || ' | ' || IFNULL(RealFirstName, '[no RealFirstName]') AS HeroName, 'x', 'x' FROM SecretIdentities; --
    // xxx' UNION SELECT IFNULL(Key, '[no Key]') || ' | ' || IFNULL(Hash, '[no Hash]') AS name, 'x', 'x' FROM HashedSecrets; --
    // xxx'; DROP TABLE Heroes;  DROP TABLE SecretIdentities; DROP TABLE HashedSecrets; --


    string where = "WHERE HeroName LIKE @searchPattern OR Power LIKE @searchPattern OR Email LIKE @searchPattern";
    readcommand.CommandText = $"{sqlBaseQuery} {where}";
    readcommand.Parameters.AddWithValue("@searchPattern", $"%{searchPattern}%");
  }
}

// TODO :
// 1. ajouter des éléments démontrant que les SqlParameters ne sont pas suffisants, Order By avec chaine directement par exemple
// 2. mettre en place un correctif pour sécuriser ce cas via une validation des entrées.
// 3. Validation des entrées par exclusion et une autre par inclusion (avantages/inconvénients).